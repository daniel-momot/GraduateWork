\chapter{Методология сравненительного анализа легковесных криптографических алгоритмов} \label{ch3}

В данной главе описывается методология сравнительного тестирования различных криптографических алгоритмов по производительности (времени работы) и по мощности энергопотребления.
	
\section{Общие принципы. Теоретический анализ} \label{ch3:sec1}

Сравнительный анализ легковесных криптографических алгоритмов разбивается на два этапа. Первый этап представляет собой теоретический анализ алгоритмов, а второй – тестирование реализаций алгоритмов.

Теоретический анализ включает в себя оценку и сравнение их стойкости в зависимости от параметров (\textit{задача криптоанализа}), а также теоретическую оценку их производительности в зависимости от тех же параметров. Под параметрами понимается конкретная конфигурация: длина ключа, число раундов, в некоторых алгоритмах также существуют различные режимы запуска и свободные параметры. Также может (и должна!) быть исследована стойкость алгоритма в зависимости от конкретного входа и конкретного ключа (слабые ключи и т. д.). 

Для определения криптостойкости легковесных шифров подходят такие же методы криптоанализа, как для шифров общего назначения. Они могут быть самыми различными: линейный криптоанализ, дифференциальный криптоанализ, атаки встречи посередине и многие другие. Они описаны в большом числе работ, например, в \cite{src53}\cite{src54}\cite{src55}\cite{src56}. Для теоретической оценки производительности можно применять обычные методы оценки времени работы алгоритма. Они описаны, например, в \cite{src57}.

В рамках тестирования реализаций алгоритмов определяют качество конкретных реализаций по таким характеристикам, как требуемая площадь микросхемы (GE-мера), фактическая производительность (производительность – число байт в секунду, плюс задержка (микро- или наносекунд)), а также энергопотребление (микроватт). Потребление ОЗУ обычно не требуется тестировать: оно легко определяется уже по псевдокоду алгоритма.

При сравнительном тестировании реализаций легковесных алгоритмов представляется разумным придерживаться следующих принципов.
\begin{itemize}
	\item Следует сравнивать реализации алгоритмов с такими параметрами запуска, которые обеспечивают одинаковую стойкость. Это требует предварительного серьезного криптоанализа тестируемых алгоритмов.
	\item Следует сравнивать реализации, использующие архитектуры одного вида. То есть сравнивать только между собой последовательные, параллельные реализации, реализации с конвейеризацией, с кэшированием и другие.
	\item Инструменты сравнения производительности должны быть постоянными (фиксированными), не «оказывать предпочтения» какому-либо из сравниваемых алгоритмов, а также минимально влиять на производительность устройств.
	\item Результаты сравнения должны быть воспроизводимыми. Поэтому следует по возможности минимизировать использование зависимостей от библиотек и фреймворков (при тестировании на ПК), а также публиковать или подробно описывать программный код реализаций и конфигурацию аппаратной части.
\end{itemize}

При сравнительном тестировании на ПК не представляется возможным протестировать площадь микросхемы, это можно проверить уже на аппаратной или аппаратно-программной реализации. Однако существуют методы приблизительной оценки производительности и энергопотребления. После чего полученные результаты для двух алгоритмов подвергаются сравнению.

\section{Оценка производительности на ПК} \label{ch3:sec2}

Производительность наиболее легко поддается измерению. Методика тестирования понятна: реализовать алгоритм, после чего запустить его несколько раз и измерить время работы. То же самое проделать для другого алгоритма и сравнить результаты.

Однако требуется, чтобы результаты по возможности были близкими к показателям на реальных малоресурсных устройствах. Ясно, что конкретные временнЫе показатели на ПК будут отличаться от таковых на низкоресурсных устройствах, однако целью является получение соотношения между производительностями алгоритмов, по возможности наиболее близкого к соотношению на низкоресурсных устройствах.

Существуют объективные ограничения точности такого способа тестирования. Фактически, они относятся к систематической (методологической) погрешности данного метода тестирования. Можно выделить следующие.

В то время как набор процессорных инструкций для устройств общего назначения более-менее стандартизирован (стандарт x86/x86-64 для ПК, ARM для мобильных и планшетных устройств), набор инструкций «кастомного» решения может несколько или даже значительно отличаться. Поэтому нужно минимизировать использование «необычных» процессорных команд. Лучше всего использовать для программной реализации язык ассемблера, это позволяет исключить процедуру трансляции языка С (бонусом также является отсутствие оптимизации последовательности команд, которая обычно происходит при компиляции программы на С). Также возможно использование языка C с отключенной оптимизацией. Наихудшим вариантом является использование наиболее высокоуровневых языков вроде С++ или Java, так как порядок их трансляции в машинные команды весьма запутанный.

Также при создании ассемблерной реализации следует учитывать предполагаемые аппаратные ограничения реализации. Они могут быть следующими:
\begin{itemize}
	\item уменьшенное количество регистров (по сравнению с ЦП ПК) \cite{src58};
	\item иная архитектура, чем у ЦП ПК. В этом случае можно моделировать задержки с помощью пустых циклов \cite{src59}.
\end{itemize}

Другой проблемой является различная скорость исполнения инструкций, т. е. задержка и пропускная способность процессора при исполнении данной инструкции. Процессоры различных производителей, линеек и поколений могут показывать различную производительность при исполнении одной и той же инструкции. Это касается стандартных ЦП для десктопных машин и ноутбуков, и уж тем более касается «кастомных» процессорных решений. Эта проблема не поддается простому решению. Можно пользоваться уже готовыми таблицами \cite{src60}, однако кастомные реализации нуждаются в отдельном тестировании для каждой используемой команды.

Еще одним неочевидным моментом является многопоточность. Ведь, даже если алгоритм запускается в однопоточном режиме, на его исполнение выделяется не 100\% процессорного времени. Значительная часть времени уходит на исполнение задач других приложений, прерываний ОС и системных прерываний. Для минимизации времени работы процессора над другими задачами следует по возможности отключить все другие приложения и службы перед началом тестирования. Можно засекать определенное время, которое затем умножить на долю q процессорного времени, выделяемого тестируемому процессу. Либо же можно сразу измерять процессорное время, например, как описано в статье \cite{src61}. Также следует отключить технологию Hyper-Threading \cite{src62}.

Еще одним возможным подходом является искусственное понижение рабочей частоты процессора. Однако этот способ имеет свои нюансы. Так, это можно сделать на уровне ОС или утилит, и в этом случае появится дополнительная активная служба, которая будет требовать отдельных ресурсов ЦП, возможно не в постоянном количестве. Также это можно выполнить на уровне BIOS \cite{src63}. Этот способ является более предпочтительным, так как не влечет появления новых служб, нагружающих ЦП. Однако этот способ (как и предыдущий) необходимо использовать с осторожностью, так как при понижении частоты ЦП некоторые службы могут отключаться. Это означает необходимость перерасчета доли процессорного времени, выделяемого тест-модулю, для каждого значения тактовой частоты ЦП.

Могут быть предложены два способа проведения измерения производительности алгоритмов. Можно либо рассчитать ее через время исполнения отдельных операций (частота процессора известна, задержки и число тактов на исполнение для каждой операции известны), либо же измерить напрямую. По мнению автора, первый подход даст очень низкую точность, либо потребует значительного тестирования или глубоких знаний в устройстве конкретного ЦП. Это связано с тем, что в процессоре имеется масса оптимизаций, которые между собой взаимодействуют. В качестве примера: последовательность команд xor rax rbx;xor rcx rdx займет время, равное не удвоенному времени исполнения xor’а, а лишь чуть дольше одного xor’а. Это связано с внутренней параллелизацией работы процессора. Большое количество разных оптимизаций не позволяет точно определить, как поведут себя операции в конкретной взаимной конфигурации, т. е. в конкретном алгоритме. Впрочем, это тема для отдельного исследования о предсказуемости времени исполнения последовательности процессорных команд.

В данной работе предлагается определять время работы алгоритма с помощью прямого тестирования времени. Случайную (статистическую) погрешность данного измерения можно уменьшить следующим способом. Произвести несколько серий измерений времени шифрования для различного объема шифруемых данных. Чем больше серий и измерений внутри серии, тем лучше. В результате точки на графике зависимости времени шифрования от объема шифруемых данных будут расположены примерно на одной прямой. После чего с помощью метода наименьших квадратов можно восстановить уравнение этой прямой вида y=kx+b. Коэффициент k будет пропускной способностью, а b – задержкой данного алгоритма. Подробнее данный классический метод описан, например, в пособии \cite{src64}.

\section{Оценка энергопотребления на ПК} \label{ch3:sec3}

Оценка энергопотребления реализации алгоритма на ПК является методологически более трудной задачей, чем оценка производительности. Основная причина в том, что на компьютере всегда в многозадачном режиме исполняются различные службы, некоторые из которых потребляют разное количество энергии в разное время. Кроме того, порядок работы служб может зависеть от загрузки ЦП, и даже от энергопотребления (например, ACPI). В результате сложно отличить колебания энергопотребления служб от работы алгоритма. Экспериментальная оценка влияния служб на энергопотребление проведена в работе \cite{src65}. Единственный способ минимизировать влияние служб на энергопотребление – отключить их.

Далее используются следующие обозначения: $P$ – мощность энергопотребления (ватт), $E$ – потребленная энергия (ватт-час).

После отключения максимально возможного количества служб можно приступать к собственно оценке энергопотребления алгоритма. Вначале опишу методика измерения энергопотребления при исполнении задачи, далее приводится порядок измерения энергопотребления на конкретном алгоритме.

Можно выделить два компонента энергопотребления ПК.
\begin{enumerate}
	\item Энергопотребление компонентов $P_{const}$.  Оно является независимым от загрузки ПК и выполняемых задач. Под компонентами имеются в виду вентилятор, материнская плата, ОЗУ (согласно  ), видеокарта (если не производятся вычисления на ней и не рисуются сложные графические объекты), HDD.
	\item Энергопотребление ЦП $P_{cpu}$. Оно в разные моменты разное: при исполнении тестируемого процесса имеет величину $P_{test}$ (собственно, ее и следует измерить), при исполнении служебных (не относящихся к процессу тестирования) процессов – усредненную величину $P_{serv}$.
\end{enumerate} 

Существует два способа измерения энергопотребления процессора: измерить энергопотребление всего ПК (на уровне блока питания) и затем вычесть $P_{const}$, или же напрямую измерить энергопотребление процессора \cite{src66} \cite{src67} (учитывается потребление на входе системной платы по разъему питания процессора \cite{src68}), при этом следует вычесть энергопотребление регулятора напряжения. Второй подход предпочтителен.

После того, как энергопотребление процессора найдено, требуется найти $P_{test}$, т. е. каким было бы энергопотребление, если бы выполнялся только тестируемый процесс. Если $q$ – доля процессорного времени, выделяемого тестируемому процессу, то усредненное по времени энергопотребление ЦП равно
\begin{equation}
P_{cpu} = q P_{test} + (1 - q)P_{serv}.
\end{equation}

Откуда получаем измеряемую величину:
\begin{equation}
P_{test} = 1/q ( P_{cpu} - (1 - q) P_{serv}).
\end{equation}

Величину $P_{serv}$ можно найти как энергопотребление ЦП в состоянии простоя, разделенное на долю его загрузки в этом режиме (утилиты для определения загрузки приводятся в \cite{src69} ). Способ оценки величины q описан в предыдущем разделе (оценка производительности).

Далее описывается измерение энергопотребление для конкретного алгоритма. По этому вопросу существует работа \cite{src71}. На ее основе предлагается следующий способ.

Измеряется $P_{bitshift}$, $P_{xor}$, … -- энергопотребление ПК при исполнении каждой из используемых в алгоритме инструкций: побитовый сдвиг, XOR и т. д. Каждый сеанс снятия этих данных следует проводить достаточно долго (хотя бы 5 минут), чтобы учесть колебания энергопотребления служб. После проведения достаточного числа таких сеансов можно узнать величину энергопотребления (микроватт) на исполнение каждой из инструкций, а также погрешность этой величины.

Измеряется частота процессора F. Это можно сделать, например, с помощью утилиты CPU-Z. По таблице (например, \cite{src60}) определяется n – число тактов на инструкцию (пропускная способность ЦП для данной инструкции). Откуда энергия, затрачиваемая на одну операцию, равна
\begin{equation}
E_{op} = \frac{ nP_{op} }{ F }.
\end{equation}

Энергия на шифрование блока или байта вычисляется как сумма энергозатрат на каждую операцию. Для обычных алгоритмов это не так просто, так как они часто имеют ветвление, в этом случае для разных веток может быть разное энергопотребление. Но шифры обычно не имеют ветвления.
\begin{equation}
E_{alg} = \mathlarger{\mathlarger{\sum}}E_{op}
\end{equation}

Если ранее была найдено время шифрования одного блока или байта, то можно найти энергопотребление алгоритма:
\begin{equation}
P_{alg} = \frac{ E_{alg} }{ t_{alg} }.
\end{equation}

Если погрешности косвенных измерений окажутся не слишком большими, то можно, зная энергопотребление каждой операции в отдельности, вычислять энергопотребление криптоалгоритма целиком без прямого тестирования. В противном случае результат можно получить и путем прямого замера, но его потребуется проводить для каждого алгоритма.

\section{Порядок сравнения избранных LWC-алгоритмов} \label{ch3:sec4}

В рамках практической части данной работы тестируется производительность избранных алгоритмов легковесной криптографии. Тестирование будет производиться на ПК с использованием вышеизложенной методологии. Результатом тестирования будет приблизительное соотношение производительностей алгоритмов. Далее полученное соотношение сравнивается с реальным соотношением производительностей для различных низкоресурсных программно-аппаратных реализаций этих же алгоритмов, полученных авторами других работ.

По результатам этого сравнения может быть сделан вывод об успешности или неуспешности предложенной методологии. Успешной она будет считаться в том случае, если результаты тестирования на ПК будут хоть в некоторой степени соотноситься с результатами сравнения реальных программно-аппаратных реализаций.

Неуспешность методологии будет означать, что тестирование производительности на ПК не отражает реальное соотношение, либо отражает в слабой степени. Успешность будет означать состоятельность данной методологии. Это позволит «прикинуть» соотношение скоростей алгоритмов-кандидатов на реализацию в конкретном программно-аппаратном решении еще до начала конструкторских работ по его созданию. Это, в свою очередь, позволит уменьшить время и стоимость таких работ.


\section{Выводы} \label{ch3:conclusion}

В данной главе была описана методология сравнительного тестирования различных криптографических алгоритмов по производительности (времени работы) и по мощности энергопотребления.

\newpage


%% Вспомогательные команды - Additional commands
%
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
%\clearpage % осуществляется пакетом <<placeins>> в пределах секций
%\newpage\leavevmode\thispagestyle{empty}\newpage % 100 % начало новой страницы