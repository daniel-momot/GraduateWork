#if _WIN32 || _WIN64
#include "windows.h"


#if _WIN64
#define ENVIRONMENT64
#else
#define ENVIRONMENT32
#endif
#endif

const void* get_func(void* page, size_t* size) {

	void* place = page;

	//const byte tmp[] = {

	//	

	//};


	const byte code[] = {
		0x50, 0x53, 0x51, 0x52, 0x56, 0x57, 0x55, 0x54,	// push rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp

		0x48, 0x89, 0xCE,						// mov    rsi,rcx
		0x48, 0x89, 0xE7,						// mov    rdi,rsp
		0x48, 0x31, 0xC9,						// xor    rcx,rcx
		0xF7, 0xE1,								// mul    ecx
		0xFF, 0xC0,								// inc eax
		0xB1, 0x04,								// mov    cl,0x4
		0x50, 0x53, 0x51, 0x52, 0x56, 0x57,		// push rax, rbx, rcx, rdx, rsi, rdi

		0x50, 0x53, 0x51, 0x52, 0x56, 0x57,		// push rax, rbx, rcx, rdx, rsi, rdi

		0x01, 0xC9,								// add    ecx,ecx
		0xF3, 0xA5,								// rep movs
		0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58,		// pop rdi, rsi, rdx, rcx, rbx, rax

		// AddRoundKey, AddRoundConstant, ExpandRoundKey

		0x50, 0x53, 0x51, 0x52, 0x56, 0x57,		// push rax, rbx, rcx, rdx, rsi, rdi (xxxx)
		0x92,									// xchg   edx,eax 
		0x48, 0x87, 0xFE,						// xchg   rsi,rdi
		0x8B, 0x46, 0x1C,						// mov    eax,[rsi+0x1c]
		0xC1, 0xC8, 0x08,						// ror    eax,0x8
		0x8B, 0x5E, 0x10,						// mov    ebx,[rsi+0x10]  (|)

		0x31, 0x1E,								// xor    [esi],ebx
		0xA5,									// movs   

		0x48, 0x8D, 0x2D, 0x02, 0x00, 0x00, 0x00,	// lea    rbp,[rip+0x2]
		0xEB, 0x7D,								// jmp    (subb)

		0xC1, 0xC8, 0x08,						// ror    eax,0x8
		0xE2, 0xF0,								// loop   (|)
		0x31, 0xD0,								// xor    eax,edx
		0xB1, 0x04,								// mov    cl,0x4
		0x31, 0x06,								// xor    [esi],eax (||)
		0xAD,									// lods   
		0xE2, 0xFB,								// loop   (||)
		0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58,		// pop rdi, rsi, rdx, rcx, rbx, rax
		0x3C, 0x6C,								// cmp    al,0x6c
		0x0F, 0x85, 0x03, 0x00, 0x00, 0x00,		// jne    (x)
		0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58,		// pop rdi, rsi, rdx, rcx, rbx, rax

		0x5C, 0x5D, 0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58, // pop rsp, rbp, rdi, rsi, rdx, rcx, rbx, rax
		0xC3,									// ret

		0x48, 0x8D, 0x2D, 0x02, 0x00, 0x00, 0x00,	// lea    rbp,[rip+0x2]
		0xE9, 0xC3, 0x00, 0x00, 0x00,			// jmp    (mult)

		// ShiftRows and SubBytes

		0x50, 0x53, 0x51, 0x52, 0x56, 0x57,		// push rax, rbx, rcx, rdx, rsi, rdi
		0xB1, 0x10,								// mov    cl,0x10
		0xAC,									// lods   (xx)

		0x48, 0x8D, 0x2D, 0x02, 0x00, 0x00, 0x00,	// lea    rbp,[rip+0x2]
		0xEB, 0x46,								// jmp    (subb)

		0x52,									// push   rdx
		0x89, 0xD3,								// mov    ebx,edx
		0x83, 0xE3, 0x03,						// and    ebx,0x3
		0xC1, 0xEA, 0x02,						// shr    edx,0x2
		0x29, 0xDA,								// sub    edx,ebx
		0x83, 0xE2, 0x03,						// and    edx,0x3
		0x8D, 0x1C, 0x93,						// lea    ebx,[ebx+edx*4]
		0x88, 0x04, 0x1F,						// mov    [edi+ebx*1],al
		0x5A,									// pop    edx
		0x42,									// inc    edx
		0xE2, 0xE2,								// loop   (xx)
		0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58,		// pop rdi, rsi, rdx, rcx, rbx, rax
		0x3C, 0x6C,								// cmp    al,0x6c
		0x74, 0xA5,								// je     (xxxx)

		// MixColumns

		0x50, 0x53, 0x51, 0x52, 0x56, 0x57,		// push rax, rbx, rcx, rdx, rsi, rdi
		0x8B, 0x07,								// mov    eax,[edi]   (yy)
		0x89, 0xC3,								// mov    ebx,eax
		0xC1, 0xC8, 0x08,						// ror    eax,0x8
		0x89, 0xC2,								// mov    edx,eax
		0x31, 0xD8,								// xor    eax,ebx

		0x48, 0x8D, 0x2D, 0x02, 0x00, 0x00, 0x00,	// lea    rbp,[rip+0x2]
		0xEB, 0x4A,								// jmp    (mult)

		0x31, 0xD0,								// xor    eax,edx
		0xC1, 0xCB, 0x10,						// ror    ebx,0x10
		0x31, 0xD8,								// xor    eax,ebx
		0xC1, 0xCB, 0x08,						// ror    ebx,0x8
		0x31, 0xD8,								// xor    eax,ebx
		0xAB,									// stos   
		0xE2, 0xE4,								// loop   (yy)
		0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58,		// pop rdi, rsi, rdx, rcx, rbx, rax
		0xEB, 0xDC,								// jmp    (xxxx)

		// SubByte (subb)

		0x50, 0x53, 0x51, 0x52, 0x56, 0x57,		// push rax, rbx, rcx, rdx, rsi, rdi
		0x84, 0xC0,								// test   al,al
		0x74, 0x22,								// je     (kkk)
		0x92,									// xchg   edx,eax
		0xB1, 0xFF,								// mov    cl,0xff
		0xB0, 0x01,								// mov    al,0x1   (zz)
		0x84, 0xE4,								// test   ah,ah    (zzz)
		0x75, 0x07,								// jne    (kkkk)
		0x38, 0xD0,								// cmp    al,dl
		0x0F, 0x94, 0xC4,						// sete   ah
		0x74, 0xF3,								// je     (zz)
		0x88, 0xC6,								// mov    dh,al  (kkkk)

		0x48, 0x8D, 0x2D, 0x02, 0x00, 0x00, 0x00,	// lea    rbp,[rip+0x2]
		0xEB, 0x00,								// jmp    ?

		0x30, 0xF0,								// xor    al,dh
		0xE2, 0xED,								// loop   (zzz)
		0x88, 0xC2,								// mov    dl,al
		0xB1, 0x04,								// mov    cl,0x4
		0xD0, 0xC2,								// rol    dl,1   (zzzz)
		0x30, 0xD0,								// xor    al,dl
		0xE2, 0xFA,								// loop   (zzzz)
		0x34, 0x63,								// xor    al,0x63  (kkk)
		0x88, 0x44, 0x24, 0x1C,					// mov    [esp+0x1c],al
		0x5F, 0x5E, 0x5A, 0x59, 0x5B, 0x58,		// pop rdi, rsi, rdx, rcx, rbx, rax
		0xC3,									// ret

		// Multiplication over GF(2**8) (mult)

		0x51,									// push   ecx
		0xB1, 0x04,								// mov    cl,0x4
		0x00, 0xC0,								// add    al,al (*)
		0x73, 0x02,								// jae    (**)
		0x34, 0x1B,								// xor    al,0x1b 
		0xC1, 0xC8, 0x08,						// ror    eax,0x8 (**)
		0xE2, 0xF5,								// loop   (*)

		0xB9, 0x02, 0x00, 0x00, 0x00,			// mov    ecx,0x2
		0x01, 0x4C, 0x24, 0x04,					// add    [esp+0x4],ecx
		0x59,									// pop    ecx
		0xC3,									// ret
	};

	memcpy(page, code, sizeof(code));
	place = (byte*) place + sizeof(code);


	*size = (byte*) place - (byte*) page;

	return page;
}


void aes_asm (const byte plaintext[16], const byte key[16], byte cipher[16])  {
	//typedef byte* (*cryptofunc)(const byte*,const byte*);
	typedef byte* (*cryptofunc)(byte*);

	void* page = VirtualAlloc(NULL, 2 * 4096, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	size_t func_size;
	const cryptofunc func = (cryptofunc) get_func(page, &func_size);
	byte* arg_place = (byte*)func + func_size;

	unsigned char concat_input[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
	memcpy(arg_place, concat_input, sizeof(concat_input));

	cipher = func(arg_place);

	VirtualFree(page, 4096, MEM_RELEASE);
}
